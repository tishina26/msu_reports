\documentclass[a4paper,12pt,titlepage,finall]{article}

\usepackage[T1,T2A]{fontenc}
\usepackage{newunicodechar}

\newunicodechar{≤}{\ensuremath{\leq}}
\usepackage[utf8x]{inputenc}
\usepackage[russian,english]{babel}
\usepackage{geometry}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{systeme,mathtools}

%Для вставки рисунков
\usepackage{graphicx}
\graphicspath{{pictures/}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=blue,
}

\usepackage{listings}
\usepackage{xcolor}

%New colors defined below
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{255,255,255}
\definecolor{ao}{rgb}{0.0, 0.5, 0.0}
\definecolor{alizarin}{rgb}{0.82, 0.1, 0.26}

%Code listing style named "mystyle"
\lstset{upquote=true}
% ДЛЯ КУСКОВ КОДА
\usepackage{listings}

\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}
\lstset{framextopmargin=50pt,frame=bottomline}
\lstdefinestyle{DEFAULT}{
  %language=NASM,
  numbers=left,
  stepnumber=1,
  numbersep=10pt,
  tabsize=4,
  showspaces=false,
  showstringspaces=false
}
\lstset{%basicstyle=\ttfamily,style=DEFAULT
    inputencoding=utf8,
    extendedchars=true,
    literate={а}{{\selectfont\char224}}1
    {б}{{\selectfont\char225}}1
    {в}{{\selectfont\char226}}1
    {г}{{\selectfont\char227}}1
    {д}{{\selectfont\char228}}1
    {е}{{\selectfont\char229}}1
    {ё}{{\"e}}1
    {ж}{{\selectfont\char230}}1
    {з}{{\selectfont\char231}}1
    {и}{{\selectfont\char232}}1
    {й}{{\selectfont\char233}}1
    {к}{{\selectfont\char234}}1
    {л}{{\selectfont\char235}}1
    {м}{{\selectfont\char236}}1
    {н}{{\selectfont\char237}}1
    {о}{{\selectfont\char238}}1
    {п}{{\selectfont\char239}}1
    {р}{{\selectfont\char240}}1
    {с}{{\selectfont\char241}}1
    {т}{{\selectfont\char242}}1
    {у}{{\selectfont\char243}}1
    {ф}{{\selectfont\char244}}1
    {х}{{\selectfont\char245}}1
    {ц}{{\selectfont\char246}}1
    {ч}{{\selectfont\char247}}1
    {ш}{{\selectfont\char248}}1
    {щ}{{\selectfont\char249}}1
    {ъ}{{\selectfont\char250}}1
    {ы}{{\selectfont\char251}}1
    {ь}{{\selectfont\char252}}1
    {э}{{\selectfont\char253}}1
    {ю}{{\selectfont\char254}}1
    {я}{{\selectfont\char255}}1
    {А}{{\selectfont\char192}}1
    {Б}{{\selectfont\char193}}1
    {В}{{\selectfont\char194}}1
    {Г}{{\selectfont\char195}}1
    {Д}{{\selectfont\char196}}1
    {Е}{{\selectfont\char197}}1
    {Ё}{{\"E}}1
    {Ж}{{\selectfont\char198}}1
    {З}{{\selectfont\char199}}1
    {И}{{\selectfont\char200}}1
    {Й}{{\selectfont\char201}}1
    {К}{{\selectfont\char202}}1
    {Л}{{\selectfont\char203}}1
    {М}{{\selectfont\char204}}1
    {Н}{{\selectfont\char205}}1
    {О}{{\selectfont\char206}}1
    {П}{{\selectfont\char207}}1
    {Р}{{\selectfont\char208}}1
    {С}{{\selectfont\char209}}1
    {Т}{{\selectfont\char210}}1
    {У}{{\selectfont\char211}}1
    {Ф}{{\selectfont\char212}}1
    {Х}{{\selectfont\char213}}1
    {Ц}{{\selectfont\char214}}1
    {Ч}{{\selectfont\char215}}1
    {Ш}{{\selectfont\char216}}1
    {Щ}{{\selectfont\char217}}1
    {Ъ}{{\selectfont\char218}}1
    {Ы}{{\selectfont\char219}}1
    {Ь}{{\selectfont\char220}}1
    {Э}{{\selectfont\char221}}1
    {Ю}{{\selectfont\char222}}1
    {Я}{{\selectfont\char223}}1
}


\geometry{a4paper,left=30mm,top=30mm,bottom=30mm,right=30mm}

\setcounter{secnumdepth}{0}      % отключаем нумерацию секций

\usepackage{hyphenat}
\usepackage{amsmath}
\usepackage{pgfplots}

\usepgfplotslibrary{fillbetween}
\usepackage{titling}
\setlength{\droptitle}{-3cm}

\usepackage{geometry}
\geometry{a4paper,left=25mm,top=25mm,bottom=30mm,right=25mm}

\usepackage{indentfirst}
\setlength{\parindent}{2em}

\usepackage{graphicx}
\usepackage{caption}
\graphicspath{ {./img/} }

\usepackage{float}
\usepackage{anyfontsize}

\begin{document}

\begin{titlepage}
	\newgeometry{a4paper,left=20mm,top=20mm,bottom=20mm,right=20mm}
	\begin{center}
	\includegraphics[height=0.5in]{msu.png}
	\hfill
	\begin{minipage}[b]{0.77\textwidth}
		\centering
		\textbf{\fontsize{12}{9}\selectfont МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ}
		\bigbreak
		\textbf{\fontsize{12}{9}\selectfont имени М.В.Ломоносова}
	\end{minipage}
	\hfill
	\includegraphics[height=0.5in]{vmk.png}
	\bigbreak
	\textbf{\fontsize{12}{9}\selectfont Факультет вычислительной математики и кибернетики}
	\end{center}
	\vspace{-0.1cm}
	\hrule
	
	\vfill
	
	\begin{center}
	{\fontsize{16}{30}\selectfont 
	\bf Компьютерный практикум по учебному курсу\\ 
				«ВВЕДЕНИЕ В ЧИСЛЕННЫЕ МЕТОДЫ» \\ 
				ЗАДАНИЕ № 1 \\
				Подвариант № 1\\}
				
	\vspace{20pt}
	
	{\fontsize{16}{30}\selectfont 
	\textbf{ОТЧЕТ\\
	о выполненном задании\\}
	студента 202 учебной группы факультета ВМК МГУ\\
	Тишиной Ульяны Кирилловны\\}
	\end{center}
	
	\vfill
	\center{гор. Москва\\ 2022 год}



\end{titlepage}

% Автоматически генерируем оглавление на отдельной странице
\tableofcontents
\newpage
\section{Цель работы 1}
Изучить классический метод Гаусса (а также модифицированный метод Гаусса), применяемый для решения системы линейных алгебраических уравнений.
\section{Постановка задачи 1}
Дана система уравнений $Ax=f$, порядка $n \times n$ с невырожденной матрицей $A$. Написать программу, решающую систему линейных алгебраических уравнений заданного пользователем размера методом Гаусса и методом Гаусса с выбором главного элемента. Предусмотреть возможность задания элементов матрицы системы и ее правой части как во входном файле данных, так и путем задания специальных формул.
\section{Задачи практической работы 1}
\begin{enumerate}
\item Решить заданную СЛАУ методом Гаусса и методом Гаусса с выбором главного элемента;
\item Вычислить определитель матрицы $\det{A}$;
\item Вычислить обратную матрицу $A^{-1}$;
\item Определить число обусловленности $M_{A}=||A|| \times ||A^{-1}||$;
\item Исследовать вопрос вычислительной устойчивости метода Гаусса (при больших значениях параметра n);
\item Правильность решения СЛАУ подтвердить системой тестов;

\end{enumerate}

\newpage

\section{Алгоритм 1}
\subsection{Метод Гауса}
Метод Гаусса решения системы лийненых алгебраических уравнений Ax = f c невырожденной матрицей A (т.е. $\det{A} \neq 0$), можно разделить на два этапа. На первом этапе
(прямой ход) система приводится к треугольному виду. На втором этапе (обратный ход) осуществляется последовательное отыскание неизвестных $x_{1}, ..., x_{n}$ из полученной треугольной системы.

\begin{enumerate}
    \item Прямой ход (приведение системы к треугольному виду): Если элемент $a_{11} = 0$, то поменяем местами (и соответственно перенумеруем) первую строчку и $i$, такую что $a_{i1} \neq 0$ (строка с таким элементом существует, т.к. $\det{A} \neq 0$ по условию). Теперь  $a_{11} \neq 0$. Разделим первое уравнение системы на $a_{11}$ (т.е. разделим на $a_{11}$ первую строку матрицы А и первый элемент вектора-столбца f). Затем из каждого следующего уравнения вычтем первое, умноженное на коэфицент $a_{i1}$. Таким образом, останется только одно уравнение с ненулевым коэффицентом при $x_{1}$. Выделим из текущей системы подсистему из $n - 1$ уравнения с перменными $x_{2}, ..., x_{n}$. Повторим данный шаг для полученной подсистемы. На $n$-м шаге получим систему $Tx=f_{1}$, где $T$ - верхняя треугольная матрица, на диагонали которой стоят единицы.
    
    \item Обратный ход (приведение системы к диагональному виду): Вычтем из $n-1$ - го уравнения системы $n$-ое, умноженное на $ t_{n-1n}$. Затем вычтем из $n-2$ - го уравнения системы $n-1$ - ое, умноженное на $t_{n-2n-1}$ и $n$-ое, умноженное на $ t_{n-2n}$ и. На $n-1$ - м шаге получим систему $Ix=y$, где $I$ - единичная матрица. Тогда $(x_{1},.., x_{n})^{T} = y$ - решение системы уравнений Ax = f
\end{enumerate}

\subsection{Метод Гауса с выбором главного элемента}
Точно такой же, как и обычный метод Гауса, только приведение к треугольному виду осуществляется с помощью выбора наибольшего по модулю элемента из оставшихся в столбце.

\newpage
\section{Описание программы 1}
Данная программа позволяет вычислять
\begin{itemize}
    \item Определитель матрицы А c использованием методома Гаусса
    \item Обратную матрицу
    \item Решение системы методом Гаусса
    \item Решение системы методом Гаусса с выбором главного элемента
\end{itemize}

Сначала программе на вход надо дать одно число - 0, если матрица составляется по формуле (тогда вектор x будет сгенерирован автоматически какк единичнй вектор, вектор f будет вычислен путем перемножения матрицы и вектора), 1-3 это номера примеров из моего варианта

Далее выполняются необходимые вычисления, параллельно выводя результаты вычислений.

\begin{enumerate}
    \item Определитель матрицы с использованием метода Гаусса
    \item Обратная матрицы 
    \item Решение системы методом Гаусса
    \item Решение системы методом Гаусса с выбором главнного элемента
\end{enumerate}

Помимо самих найденных векторов при решении методом Гауса выводятся матрицы после приведения к треугольному виду.

\subsection{Функция main}
Программа начинает своё выполнение в функции
\begin{verbatim}
int main(int argc, char **argv)
\end{verbatim}

Здесь программа узнает, какую систему решать. Инициализируются массивы, вызываются функции нахождения определителя и обратной матрицы, функции решения системы и функции вывода ответов.


Также задаются константы eps = $10^{-6}$ и константы для формирования матрицы по формуле.


\subsection{Функции нахождения определителя и обратной матрицы}

\begin{verbatim}
double determinant(double **matr, int n)
\end{verbatim}

Функция принимает матрицу и размер матрицы, возвращает определитель матрицы.

\begin{verbatim}
double **inverse_matrix(double **matr, int n)
\end{verbatim}

Принимает матрицу и ее размер, возвращает обратную матрицу

\subsection{Функции решения системы}

\begin{verbatim}
double* GAUSS_method(double **arr, double *f, int n, int flag)
\end{verbatim}

Функция решения системы
Принимает матрицу, вектор правой части, размер и флаг, отвечающий за то, каким способом приводить матрицу к треугольному виду - с выбором главного элемента или нет. (флаг = 1, если без выбора главного элемента, = 2, если с выбором)
Заодно выводит, какой стала система после приведения к треугольному виду.

\begin{verbatim}
void make_triangle(double** arr, int n, double* f,
    void find_not_null_elem(double** arr, int n, double* f, int i))
\end{verbatim}

Фунция приведения матрицы к треугольному виду.
Принимает матрицу, размер матрицы, вектор правой части и указатель на ту функцию, которой находить строку для того, чтобы переместить ее на нужную строку в цикле. Ничего не возвращает, работает с матрицей.

\begin{verbatim}
void find_not_null_elem_max(double** arr, int n, double* f, int i)
\end{verbatim}

Функция находит максимальный по модулю элемент в столбце.
Принимает матрицу, размер матрицы, вектор правой части и индекс столбца, в котором надо найти максимальный элемент.
Функция ничего не возвращает, т к сама ставит найденную строку на i-ю строку.

\begin{verbatim}
void find_not_null_elem_1(double** arr, int n, double* f, int i)
\end{verbatim}

Функция находит первый ненулевой элемент в столбце и ставит его на текущую строку.
Принимает матрицу, размер. вектор правой части и индекс текущего столбца.

\subsection{Функции вывода}

\begin{verbatim}
void print_matrix(double **arr, int n, double *f)
\end{verbatim}

Выводит систему. Принимает на вход матрицу, размер и вектор правой части. Если вектора правой части нет, то будет вместо его значений выводить просто букву f, чтобы сохранить вид системы и было удобнее читать. Так же между элементов матрицы выводит букву x, тоже для более удобного чтения.

\begin{verbatim}
void print_vector(double *x, int n)
\end{verbatim}

Выводит вектор, который принимает на вход. Выводит в горизонтальном виде. Принимает на вход вектор и размер.


\subsection{Вспомогательный функции}

\begin{verbatim}
double** copy_matrix(double **a, int n)
\end{verbatim}

Принимает на вход матрицу и размер. Возвращает матрицу, копию введенной. (Функция нужна, чтобы в программе менять копию матрицы, а исходную матрицу не трогать, зато потом можно сделать еще копии для других функций)

\begin{verbatim}
double* copy_vector(double *x, int n)
\end{verbatim}

Принимает на вход вектор и его размер, возвращает копию этого вектора. Назначение, как у предыдущей функции.

\begin{verbatim}
void gen_matrix(int n, double ***arr)
\end{verbatim}

Генерирует матрицу по формуле. Не возвращает эту матрицу, а изменяет ту, что дают на вход.

\begin{verbatim}
void find_f_vector(double **arr, double **f, int n)
\end{verbatim}

Генерирует вектор правой части. Принимает на вход матрицу, указатель на вектор правой части и размер. Предполагается, что решение системы - единичный вектор (чтобы удобнее было проверять ответ, т к в этом случае размер матрицы большой). Тогда для нахождения вектора правой части нужно перемножить матрицу и единичный вектор.

\begin{verbatim}
void free_all(double **m, double *v, int n)
\end{verbatim}

Функция освобождает память матрицы и вектора, которые получает на вход. Так же на вход подается размер.

\newpage
\section{Код программы 1}
\begin{lstlisting}[language=C, caption=main.c]
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

static double det = 1.0;
double tmp_num;

void print_matrix(double **arr, int n, double *f) {
    for (int i = 0; i < n; i++) {
        printf("|");
        for (int j = 0; j < n; j++) {
            printf("%10.5lf ", arr[i][j]);
        }

        printf(" |  *  |x|  =  ");
        if (f) {
            printf("|%10.5lf |\n", f[i]);
        } else {
            printf("| f |\n");
        }
    }

    printf("\n");

    return;
}

void print_vector(double *x, int n) {
    for (int i = 0; i < n; i++) {
        printf("%10.5lf ", x[i]);
    }

    printf("\n");
}

double** copy_matrix(double **a, int n) {
    double** arr = calloc(n, sizeof(*arr));

    for (int i = 0; i < n; i++) {
        arr[i] = calloc(n, sizeof(*arr[i]));

        for (int j = 0; j < n; j++) {
            arr[i][j] = a[i][j];
        }
    }

    return arr;
}

double* copy_vector(double *x, int n) {
    double* ans = calloc(n, sizeof(*ans));

    for (int i = 0; i < n; i++) {
        ans[i] = x[i];
    }

    return ans;
}

void gen_matrix(int n, double ***arr) {
    int num = 2, mod = 7;
    double c = 0.01;
    tmp_num = 0.0;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j) {
                ((*arr)[i][j]) = (double) (((i + 1) * num + j) % mod);
            } else {
                ((*arr)[i][j]) = c;
            }
            if ((*arr)[i][j] > tmp_num) {
                tmp_num = (*arr)[i][j];
            }
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            (*arr)[i][j] /= tmp_num;
        }
    }
}

void find_not_null_elem_1(double** arr, int n, double* f, int i) {
    int k = i;
    while ((k < n - 1) && (arr[k][i] == 0.0)) {
        k++;
    }

    double *tmp = arr[i];
    arr[i] = arr[k];
    arr[k] = tmp;

    if (f) {
        double tmp1 = f[i];
        f[i] = f[k];
        f[k] = tmp1;
    }
    return;
}

void find_not_null_elem_max(double** arr, int n, double* f, int i) {
    int k = i, i_max = i;
    double max = arr[i][i];

    for (int k = i; k < n - 1; k++) {
        if ((arr[k][i] != 0) && (arr[k][i] > max)) {
            max = arr[k][i];
            i_max = k;
        }
    }

    double *tmp = arr[i];
    arr[i] = arr[i_max];
    arr[i_max] = tmp;

    if (f) {
        double tmp1 = f[i];
        f[i] = f[i_max];
        f[i_max] = tmp1;
    }
    return;
}

void make_triangle(double** arr, int n, double* f,
    void find_not_null_elem(double** arr, int n, double* f, int i)) {

    for (int i = 0; i < n - 1; i++) {
        (*find_not_null_elem)(arr, n, f, i);
        double koef = arr[i][i];
        if (koef == 0) {
            printf("Определитель матрицы = 0, пожалуйста, введите другую матрицу\n");
            exit(0);
        }

        if (f) {
            f[i] /= koef;
        }
        for (int j = i; j < n; j++) {
            arr[i][j] /= koef;
        }
        for (int j = i + 1; j < n; j++) {
            koef = arr[j][i];
            if (f) {
                f[j] -= koef * f[i];
            }
            for (int k = i; k < n; k++) {
                arr[j][k] -= koef * arr[i][k];
            }
        }
    }
}

void find_f_vector(double **arr, double **f, int n) {
    for (int i = 0; i < n; i++) {
        double a = 0.0;
        for (int j = 0; j < n; j++) {
            a += arr[i][j];
        }
        (*f)[i] = a;
    }
}

double* GAUSS_method(double **arr, double *f, int n, int flag) {
    double *x = calloc(n, sizeof(*x));
    
    printf("\nПриведенная система:\n");

    if (flag = 1) {
        make_triangle(arr, n, f, find_not_null_elem_1);
    } else {
        make_triangle(arr, n, f, find_not_null_elem_max);
    }

    print_matrix(arr, n, f);

    x[n - 1] = f[n - 1] / arr[n - 1][n - 1];

    for (int i = n - 2; i >= 0; i--) {
        arr[i][i] = f[i];

        for (int j = i + 1; j < n; j++) {
            arr[i][i] -= arr[i][j] * x[j]; 
        }

        x[i] = arr[i][i];
    }

    return x;
}

double determinant(double **matr, int n){
    int i, j, k;
    double max_elem, buf, det = 1, buf_matr;
    for (i = 0; i < n; i++) {
        max_elem = matr[i][i];
        k = i;
        for(j = i + 1; j < n; j++) {
            if (fabs(max_elem) < fabs(matr[j][i])) {
                max_elem = matr[j][i];
                k = j;
            }
        }
        if (k != i) {
            det = det * (-1);
            for (j = i; j < n; j++) {
                buf = matr[i][j];
                matr[i][j] = matr[k][j];
                matr[k][j] = buf;
            }
        }
        det *= matr[i][i];
        buf_matr = matr[i][i];
        for (j = i; j < n; j++) {
            matr[i][j] /= buf_matr;
        }
        for (k = i + 1; k < n; k++) {
            if (matr[k][i] != 0) {
                for (j = i + 1; j < n; j++) {
                    matr[k][j] -= matr[i][j] * matr[k][i];
                }
                matr[k][i] = 0;
            }
        }
    }
    return det;
}

double **inverse_matrix(double **matr, int n){
    double **res, max_elem, buf, buf_matr;
    int i, j, k;
    res = calloc(n, sizeof(*res));
    for (i = 0; i < n; i++) {
        res[i] = calloc (n, sizeof(**res));
    }
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            if (i == j) {
                res[i][j] = 1.0;
            } else {
                res[i][j] = 0.0;
            }
        }
    }
    for (i = 0; i < n; i++) {
        max_elem = matr[i][i];
        k = i;
        for(j = i + 1; j < n; j++) {
            if (fabs(max_elem) < fabs(matr[j][i])) {
                max_elem = matr[j][i];
                k = j;
            }
        }
        if (k != i) {
            for (j = i; j < n; j++) {
                buf = matr[i][j];
                matr[i][j] = matr[k][j];
                matr[k][j] = buf;
            }
            for (j = 0; j < n; j++) {
                buf = res[i][j];
                res[i][j] = res[k][j];
                res[k][j] = buf;
            }
        }
        buf_matr = matr[i][i];
        for (j = i; j < n; j++) {
            matr[i][j] /= buf_matr;
        }
        for (j = 0; j < n; j++) {
            res[i][j] /= buf_matr;
        }
        for (k = i + 1; k < n; k++) {
            if (matr[k][i] != 0) {
                for (j = 0; j < n; j++) {
                    res[k][j] -= res[i][j] * matr[k][i];
                }
                for (j = i + 1; j < n; j++) {
                    matr[k][j] -= matr[i][j] * matr[k][i];
                }
                matr[k][i] = 0;
            }
        }
    }
    for (i = n - 1; i >= 0; i--) {
        for (j = i - 1; j >= 0; j--) {
            for (k = 0; k < n; k++) {
                res[j][k] -= res[i][k] * matr[j][i];
            }
        }
    }
    return res;
}

void free_all(double **m, double *v, int n) {
    for (int i = 0; i < n; i++) {
        free(m[i]);
    }
    free(m);
    free(v);
}

int main(int argc, char **argv) {
    printf("Введите способ ввода матриц\n");
    printf("0 - по формуле, или 1 или 2 или 3 - номер примера\n");
    int n = 4, flag;
    scanf("%d", &flag);
    if (flag == 0) n = 40;

    double **matrix = calloc(n, sizeof(*matrix));
    for (int i = 0; i < n; i++) matrix[i] = calloc(n, sizeof(**matrix));
    double *f_vector = calloc(n, sizeof(*f_vector));
    
    if (flag == 0) {
        gen_matrix(n, &matrix);
        find_f_vector(matrix, &f_vector, n);
        printf("\nСгенерированная система:\n");
        printf("Сгенерированный вектор x всегда единичный вектор длины n\n");
        print_matrix(matrix, n, f_vector);
        
    } else {
        FILE *fd;
        if (flag == 1) {
            fd = fopen("/home/uliana/Programm/CHMI/1.txt", "r");
        } else if (flag == 2) {
            fd = fopen("/home/uliana/Programm/CHMI/2.txt", "r");
        } else {
            fd = fopen("/home/uliana/Programm/CHMI/3.txt", "r");
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                fscanf(fd, "%lf", &matrix[i][j]);
            }
            fscanf(fd, "%lf", &f_vector[i]);
        }
        fclose(fd);
    }

    double **matrix_1 = nULL;
    double *vector_f1 = nULL;

    matrix_1 = copy_matrix(matrix, n);
    vector_f1 = copy_vector(f_vector, n);

    
    if (flag == 0) {
        printf("\tОпределитель равен %lf * %lf ^ %d\n\n", determinant(matrix_1, n), tmp_num, n);
    } else printf("\tОпределитель равен %lf\n\n", determinant(matrix_1, n));
    free_all(matrix_1, vector_f1, n);
    
    
    matrix_1 = copy_matrix(matrix, n);
    vector_f1 = copy_vector(f_vector, n);
    
    
    matrix_1 = inverse_matrix(matrix_1, n);
    printf("\tОбратная матрица:\n");
    print_matrix(matrix_1,n,nULL);
    free_all(matrix_1, vector_f1, n);
    
    
    
    matrix_1 = copy_matrix(matrix, n);
    vector_f1 = copy_vector(f_vector, n);

    
    
    printf("\n\tВ результате обычного метода Гаусса\n");
    double *ans_x_1 = GAUSS_method(matrix_1, vector_f1, n, 1);
    printf("Вектор х получился\n");
    print_vector(ans_x_1, n);
    free_all(matrix_1, vector_f1, n);

    
    matrix_1 = copy_matrix(matrix, n);
    vector_f1 = copy_vector(f_vector, n);
    
    
    printf("\n\tВ результате метода Гаусса с выбором максимального элемента\n");
    double *ans_x_2 = GAUSS_method(matrix_1, vector_f1, n, 2);
    printf("Вектор х получился\n");
    print_vector(ans_x_2, n);
    free_all(matrix_1, vector_f1, n);

    free_all(matrix, f_vector, n);

    return 0;
}
\end{lstlisting}


\section{Тестирование программы 1}
Проверка корректности программы проведена с помощью тестов из моего варианта и онлайн программ, позволяющих вычислить определитель матрицы,обратную матрицу или решить систему.

\subsection{Приложение 1. Вариант 9.}
\subsubsection{Первая система}

\begin{equation*}
 \begin{cases}
   2x_1 - 5x_2 + 3x_3 + x_4 = 5, 
   \\
   3x_1 - 7x_2 + 3x_3 - x_4 = -1,
   \\
   5x_1 - 9x_2 + 6x_3 + 2x_4 = 7,
   \\
   4x_1 - 6x_2 + 3x_3 + x_4 = 8,
 \end{cases}
\end{equation*}

Вывод моей программы:

\begin{verbatim}

Введите способ ввода матриц
0 - по формуле, или 1 или 2 или 3 - номер примера
1
        Определитель равен 18.000000

        Обратная матрица:
|  -1.00000   -0.00000    0.33333    0.33333  |  *  |x|  =  | f |
|  -1.00000    0.00000    0.66667   -0.33333  |  *  |x|  =  | f |
|  -1.00000    0.16667    1.05556   -0.94444  |  *  |x|  =  | f |
|   1.00000   -0.50000   -0.50000    0.50000  |  *  |x|  =  | f |


        В результате обычного метода Гаусса

Приведенная система:
|   1.00000   -2.50000    1.50000    0.50000  |  *  |x|  =  |   2.50000 |
|   0.00000    1.00000   -3.00000   -5.00000  |  *  |x|  =  | -17.00000 |
|   0.00000    0.00000    1.00000    1.88889  |  *  |x|  =  |   6.00000 |
|   0.00000    0.00000    0.00000    2.00000  |  *  |x|  =  |  12.00000 |

Вектор х получился
  -0.00000   -3.00000   -5.33333    6.00000 

        В результате метода Гаусса с выбором максимального элемента

Приведенная система:
|   1.00000   -2.50000    1.50000    0.50000  |  *  |x|  =  |   2.50000 |
|   0.00000    1.00000   -3.00000   -5.00000  |  *  |x|  =  | -17.00000 |
|   0.00000    0.00000    1.00000    1.88889  |  *  |x|  =  |   6.00000 |
|   0.00000    0.00000    0.00000    2.00000  |  *  |x|  =  |  12.00000 |

Вектор х получился
  -0.00000   -3.00000   -5.33333    6.00000 

\end{verbatim}

Определитель матрицы и обратная были найдены с помощью сайта
\\https://ru.onlinemschool.com/math/assistance/matrix/determinant/

Решение системы были найдены с помощью сайта
\\https://ru.onlinemschool.com/math/assistance/equation/matr/

(Относится ко всем трем системам Приложения 1)

Вывод программы совпал с ответами на сайтах, значит, программа работает верно.

\subsubsection{Вторая система}

\begin{equation*}
 \begin{cases}
   4x_1 + 3x_2 - 9x_3 + x_4 = 9
   \\
   2x_1 + 5x_2 - 8x_3 - x_4 = 8
   \\
   2x_1 + 16x_2 - 14x_3 + 2x_4 = 24
   \\
   2x_1 + 3x_2 - 5x_3  - 11x_4 = 7
 \end{cases}
\end{equation*}


Вывод моей программы:

\begin{verbatim}
Введите способ ввода матриц
0 - по формуле, или 1 или 2 или 3 - номер примера
2
        Определитель равен -868.000000

        Обратная матрица:
|   0.68894   -1.36406    0.25346    0.23272  |  *  |x|  =  | f |
|   0.11751   -0.50691    0.18203    0.08986  |  *  |x|  =  | f |
|   0.23963   -0.77880    0.17512    0.12442  |  *  |x|  =  | f |
|   0.04839   -0.03226    0.01613   -0.08065  |  *  |x|  =  | f |


        В результате обычного метода Гаусса

Приведенная система:
|   1.00000    0.75000   -2.25000    0.25000  |  *  |x|  =  |   2.25000 |
|   0.00000    1.00000   -1.00000   -0.42857  |  *  |x|  =  |   1.00000 |
|   0.00000    0.00000    1.00000    1.54286  |  *  |x|  =  |   1.00000 |
|   0.00000    0.00000    0.00000  -12.40000  |  *  |x|  =  |   0.00000 |

Вектор х получился
   3.00000    2.00000    1.00000   -0.00000 

        В результате метода Гаусса с выбором максимального элемента

Приведенная система:
|   1.00000    0.75000   -2.25000    0.25000  |  *  |x|  =  |   2.25000 |
|   0.00000    1.00000   -1.00000   -0.42857  |  *  |x|  =  |   1.00000 |
|   0.00000    0.00000    1.00000    1.54286  |  *  |x|  =  |   1.00000 |
|   0.00000    0.00000    0.00000  -12.40000  |  *  |x|  =  |   0.00000 |

Вектор х получился
   3.00000    2.00000    1.00000   -0.00000 


\end{verbatim}


Вывод программы совпал с ответами на сайтах, значит, программа работает верно.

\subsubsection{Третья система}

\begin{equation*}
 \begin{cases}
   12x_1 + 14x_2 - 15x_3 + 24x_4 = 5 
   \\
   16x_1 + 18x_2 - 22x_3 + 24x_4 = 8
   \\
   18x_1 + 20x_2 - 21x_3 + 32x_4 = 9
   \\
   10x_1 + 12x_2 - 16x_3 + 20x_4 = 4
 \end{cases}
\end{equation*}


Вывод моей программы:

\begin{verbatim}
Введите способ ввода матриц
0 - по формуле, или 1 или 2 или 3 - номер примера
3
        Определитель равен 36.000000

        Обратная матрица:
|   1.00000    2.88889   -1.66667   -2.72222  |  *  |x|  =  | f |
|  -2.50000   -4.66667    3.50000    4.16667  |  *  |x|  =  | f |
|   0.00000   -0.44444    0.33333    0.11111  |  *  |x|  =  | f |
|   1.00000    1.00000   -1.00000   -1.00000  |  *  |x|  =  | f |


        В результате обычного метода Гаусса

Приведенная система:
|   1.00000    1.16667   -1.25000    2.00000  |  *  |x|  =  |   0.41667 |
|   0.00000    1.00000    3.00000    4.50000  |  *  |x|  =  |  -2.00000 |
|   0.00000    0.00000    1.00000    0.11111  |  *  |x|  =  |  -0.11111 |
|   0.00000    0.00000    0.00000   -1.00000  |  *  |x|  =  |   0.00000 |

Вектор х получился
   2.22222   -1.66667   -0.11111   -0.00000 

        В результате метода Гаусса с выбором максимального элемента

Приведенная система:
|   1.00000    1.16667   -1.25000    2.00000  |  *  |x|  =  |   0.41667 |
|   0.00000    1.00000    3.00000    4.50000  |  *  |x|  =  |  -2.00000 |
|   0.00000    0.00000    1.00000    0.11111  |  *  |x|  =  |  -0.11111 |
|   0.00000    0.00000    0.00000   -1.00000  |  *  |x|  =  |   0.00000 |

Вектор х получился
   2.22222   -1.66667   -0.11111   -0.00000 

\end{verbatim}


Вывод программы совпал с ответами на сайтах, значит, программа работает верно.

\newpage

\subsection{Приложение 2. Вариант 2-2}

Формуру я придумала сама, в коде программы можно посмотреть ее реализацию.

Программа выводит в том числе и сгенерированную матрицу и вектор правой части.
Размер матрицы 20 на 20.


Вывод моей программы:

\begin{verbatim}
Введите способ ввода матриц
0 - по формуле, или 1 или 2 или 3 - номер примера
0

Сгенерированная система:
Сгенерированный вектор x всегда единичный вектор длины n
|   0.33333    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.36500 |
|   0.00167    0.83333    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.86500 |
|   0.00167    0.00167    0.16667    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.19833 |
|   0.00167    0.00167    0.00167    0.66667    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.69833 |
|   0.00167    0.00167    0.00167    0.00167    0.00000    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.03167 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.50000    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.53167 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    1.00000    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   1.03167 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.33333    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.36500 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.83333    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.86500 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.16667    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.19833 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.66667    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.69833 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00000    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.03167 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.50000    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.53167 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    1.00000    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   1.03167 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.33333    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.36500 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.83333    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.86500 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.16667    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.19833 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.66667    0.00167    0.00167  |  *  |x|  =  |   0.69833 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00000    0.00167  |  *  |x|  =  |   0.03167 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.50000  |  *  |x|  =  |   0.53167 |

        Определитель равен 0.000000 * 6.000000 ^ 20

        Обратная матрица:
|   3.02293    0.00313    0.01580    0.00392   -1.56406    0.00523    0.00261    0.00786    0.00313    0.01580    0.00392   -1.56406    0.00523    0.00261    0.00786    0.00313    0.01580    0.00392   -1.56406    0.00523  |  *  |x|  =  | f |
|   0.00313    1.20365    0.00630    0.00156   -0.62375    0.00209    0.00104    0.00313    0.00125    0.00630    0.00156   -0.62375    0.00209    0.00104    0.00313    0.00125    0.00630    0.00156   -0.62375    0.00209  |  *  |x|  =  | f |
|   0.01580    0.00630    6.09236    0.00788   -3.14393    0.01051    0.00525    0.01580    0.00630    0.03176    0.00788   -3.14393    0.01051    0.00525    0.01580    0.00630    0.03176    0.00788   -3.14393    0.01051  |  *  |x|  =  | f |
|   0.00392    0.00156    0.00788    1.50571   -0.78007    0.00261    0.00130    0.00392    0.00156    0.00788    0.00196   -0.78007    0.00261    0.00130    0.00392    0.00156    0.00788    0.00196   -0.78007    0.00261  |  *  |x|  =  | f |
|  -1.56406   -0.62375   -3.14393   -0.78007 -288.75122   -1.04097   -0.51961   -1.56406   -0.62375   -3.14393   -0.78007  311.24878   -1.04097   -0.51961   -1.56406   -0.62375   -3.14393   -0.78007  311.24878   -1.04097  |  *  |x|  =  | f |
|   0.00523    0.00209    0.01051    0.00261   -1.04097    2.01017    0.00174    0.00523    0.00209    0.01051    0.00261   -1.04097    0.00348    0.00174    0.00523    0.00209    0.01051    0.00261   -1.04097    0.00348  |  *  |x|  =  | f |
|   0.00261    0.00104    0.00525    0.00130   -0.51961    0.00174    1.00254    0.00261    0.00104    0.00525    0.00130   -0.51961    0.00174    0.00087    0.00261    0.00104    0.00525    0.00130   -0.51961    0.00174  |  *  |x|  =  | f |
|   0.00786    0.00313    0.01580    0.00392   -1.56406    0.00523    0.00261    3.02293    0.00313    0.01580    0.00392   -1.56406    0.00523    0.00261    0.00786    0.00313    0.01580    0.00392   -1.56406    0.00523  |  *  |x|  =  | f |
|   0.00313    0.00125    0.00630    0.00156   -0.62375    0.00209    0.00104    0.00313    1.20365    0.00630    0.00156   -0.62375    0.00209    0.00104    0.00313    0.00125    0.00630    0.00156   -0.62375    0.00209  |  *  |x|  =  | f |
|   0.01580    0.00630    0.03176    0.00788   -3.14393    0.01051    0.00525    0.01580    0.00630    6.09236    0.00788   -3.14393    0.01051    0.00525    0.01580    0.00630    0.03176    0.00788   -3.14393    0.01051  |  *  |x|  =  | f |
|   0.00392    0.00156    0.00788    0.00196   -0.78007    0.00261    0.00130    0.00392    0.00156    0.00788    1.50571   -0.78007    0.00261    0.00130    0.00392    0.00156    0.00788    0.00196   -0.78007    0.00261  |  *  |x|  =  | f |
|  -1.56406   -0.62375   -3.14393   -0.78007  311.24878   -1.04097   -0.51961   -1.56406   -0.62375   -3.14393   -0.78007 -288.75122   -1.04097   -0.51961   -1.56406   -0.62375   -3.14393   -0.78007  311.24878   -1.04097  |  *  |x|  =  | f |
|   0.00523    0.00209    0.01051    0.00261   -1.04097    0.00348    0.00174    0.00523    0.00209    0.01051    0.00261   -1.04097    2.01017    0.00174    0.00523    0.00209    0.01051    0.00261   -1.04097    0.00348  |  *  |x|  =  | f |
|   0.00261    0.00104    0.00525    0.00130   -0.51961    0.00174    0.00087    0.00261    0.00104    0.00525    0.00130   -0.51961    0.00174    1.00254    0.00261    0.00104    0.00525    0.00130   -0.51961    0.00174  |  *  |x|  =  | f |
|   0.00786    0.00313    0.01580    0.00392   -1.56406    0.00523    0.00261    0.00786    0.00313    0.01580    0.00392   -1.56406    0.00523    0.00261    3.02293    0.00313    0.01580    0.00392   -1.56406    0.00523  |  *  |x|  =  | f |
|   0.00313    0.00125    0.00630    0.00156   -0.62375    0.00209    0.00104    0.00313    0.00125    0.00630    0.00156   -0.62375    0.00209    0.00104    0.00313    1.20365    0.00630    0.00156   -0.62375    0.00209  |  *  |x|  =  | f |
|   0.01580    0.00630    0.03176    0.00788   -3.14393    0.01051    0.00525    0.01580    0.00630    0.03176    0.00788   -3.14393    0.01051    0.00525    0.01580    0.00630    6.09236    0.00788   -3.14393    0.01051  |  *  |x|  =  | f |
|   0.00392    0.00156    0.00788    0.00196   -0.78007    0.00261    0.00130    0.00392    0.00156    0.00788    0.00196   -0.78007    0.00261    0.00130    0.00392    0.00156    0.00788    1.50571   -0.78007    0.00261  |  *  |x|  =  | f |
|  -1.56406   -0.62375   -3.14393   -0.78007  311.24878   -1.04097   -0.51961   -1.56406   -0.62375   -3.14393   -0.78007  311.24878   -1.04097   -0.51961   -1.56406   -0.62375   -3.14393   -0.78007 -288.75122   -1.04097  |  *  |x|  =  | f |
|   0.00523    0.00209    0.01051    0.00261   -1.04097    0.00348    0.00174    0.00523    0.00209    0.01051    0.00261   -1.04097    0.00348    0.00174    0.00523    0.00209    0.01051    0.00261   -1.04097    2.01017  |  *  |x|  =  | f |


        В результате обычного метода Гаусса

Приведенная система:
опущено для удобства отчета

Вектор х получился
   1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000 

        В результате метода Гаусса с выбором максимального элемента

Приведенная система:
опущено для удобства отчета

Вектор х получился
   1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000 
\end{verbatim}


Заметим, что вектор ответа получился единичным, как и было изначально, значит, система решена верно. Определитель найдет по формуле через число обусловленности. Обратная матрица была проверена с помощью умножения изначальной на обратную. Получилась единичная, значит, обратная была найдена верно.


\newpage


\section{Цель работы 2}
Изучить классические итерационные методы (Зейделя и верхней релаксации),
используемые для численного решения систем линейных алгебраических уравнений;
изучить скорость сходимости этих методов в зависимости от выбора итерационного
параметра.
\section{Постановка задачи 2}
Дана система уравнений Ax = f порядка n × n с невырожденной матрицей A. Написать
программу, численного решения данной системы линейных алгебраических уравнений
(n - параметр программы), использующий численный алгоритм итерационного метода
верхней релаксации:

где D, A - соответственно диагональная и нижняя треугольная матрицы,
k – номер текущей итерации, $\omega$ – итерационный параметр (при $\omega$ = 1 метод верхней
релаксации переходит в метод Зейделя).
Предусмотреть возможность задания элементов матрицы системы и её правой части
как во входном файле данных, так и путём задания специальных формул.
\section{Задачи практической работы 2}
\begin{enumerate}
\item Решить систему методом верхней релаксации;
\item Разработать критерий остановки итерационного процесса, гарантирующий
получение приближение решения исходной СЛАУ с заданной точностью;
\item Изучить скорость сходимости итераций к точному решению задачи. Рассмотреть
результаты при различных параметрах $\omega$ (в случае симметрической
положительно определённой матрицы системы известно, что для сходимости
итераций следует выбрать 0 < $\omega$ < 2;
\item Правильность решения подтвердить системой тестов;
\end{enumerate}
\newpage

\section{Алгоритм 2}
\subsection{Метод верхней релаксации}
Данный метод является стационарным итерационным методом решения СЛАУ: Ax = f.
Рекуррентная формула для итерационного подсчета выглядит следующим образом: 

$(D + \omega * A{(-)})(x^{k+1} - x^{k}) / \omega + Ax^{k} = f$,

где D , A - соответственно диагональная и нижняя треугольная матрицы, k – номер текущей итерации, $\omega$ – итерационный параметр. Тогда для компоненты очередной итерации вычисляются по формулам:

$x_{i}^{k+1} = x_{i}^{k} + \omega /a_{ii}$

\subsection{Условие сходимости}

Если матрица A удовлетворяет условиям теоремы Самарского (A - самосопряженная положительно определенная матрица: A = A , A > 0, достаточное условие для сходимости итерационной последовательности метода верхней релаксации принимает вид: 0 < $\omega$ < 2 . Метод Зейделя, соответствующий случаю $\omega$ = 1, удовлетворяет этому условию.
Если начальная матрица A, не удовлетворяет заданным условиям, то мы умножаем ее и правую часть f на $A^{T}$ . Решение системы от этого не изменится, однако матрица коэффициентов $A^{T}$ A будет самосопряженной и положительно определенной.
\subsection{Критерий остановки}

Для исследования его сходимости введем следующую характеристику – невязку : 
$\psi$ $_{k} = Ax_{k} - f$ . Она показывает, насколько хорошо или, наоборот, плохо член итерационной последовательности удовлетворяет исходной системе.
 Критерием остановки итерационного процесса будем считать значение нормы невязки, которое меньше заданной точности: ||Ax - f||< $\epsilon$ .

\newpage
\section{Описание программы 2}
Данная программа позволяет решить систему с помощью метода верхней релаксации. Тут использовано много функций, копируемых из первой программы, поэтому в коде этой программы они будут даны не полностью, а только в качестве прототипов.

Ввод матрицы абсолютно аналогичен программе 1. Далее идет сразу решение системы.

\subsection{Функция main}
Программа начинает своё выполнение в функции
\begin{verbatim}
int main(int argc, char **argv)
\end{verbatim}

Здесь программа узнает, какую систему решать. Инициализируются массивы, вызываются функции решения системы и функции вывода ответов.

Также задаются константы $eps = 10^{-6}$ и константы для формирования матрицы по формуле.


\subsection{Функции решения системы}

\begin{verbatim}
int over_relaxation_method(double **matrix, double *f, int n, double omega, double eps)
\end{verbatim}

Функция решения системы
Принимает матрицу, вектор правой части, размер и омегу и епсилон(точность)
Реализован метод верзней релаксации и возвращается количество совершенных операций.

\begin{verbatim}
double convergence(double *ans, double **matrix, double *f, int n)
\end{verbatim}

Принимает вектор текущего ответа, матрицу, вектор текущей правой части и размер.
Функция считает невязку и возвращает это число.

\begin{verbatim}
double **matrix_transpose(double **matrix, int n)
\end{verbatim}

Транспонирует матрицу, возвращает транспонированную матрицу. Принимает матрицу и размер.

\begin{verbatim}
double **matrix_multiplication(double **matrix_1, double **matrix_2, int n)
\end{verbatim}

Перемножает две матрицы и врзвращает результат. Принимает две матрицы и размер.

\begin{verbatim}
double *matr_to_vec_mult(double **matr, double *vector, int n)
\end{verbatim}

Умножает матрицу на вектор. Принимает матрицу, вектор и размер. Возвращает результат умножения - вектор

\subsection{Функции вывода}

Аналогично программе 1

\subsection{Вспомогательный функции}

Аналогично программе 1

\newpage
\section{Код программы 2}
\begin{lstlisting}

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

double *ans;
double tmp_num;

void print_matrix(double **arr, int n, double *f);
void print_vector(double *x, int n);
double** copy_matrix(double **a, int n);
double* copy_vector(double *x, int n);
void gen_matrix(int n, double ***arr);
void find_f_vector(double **arr, double **f, int n);

double convergence(double *ans, double **matrix, double *f, int n) {
    double norm = 0., sum;
    int i, j;
    for (i = 0; i < n; i++) {
        sum = 0.;
        for (j = 0; j < n; j++) {
            sum += matrix[i][j] * ans[j];
        }
        sum -= f[i];
        norm += sum * sum;
    }
    return sqrt(norm);
}

int over_relaxation_method(double **matrix, double *f, int n, double omega, double eps) {
    int i, j, step = 0;
    double *pre_ans, sum;
    pre_ans = calloc(n, sizeof(*pre_ans));
    memset(pre_ans, 0, n);
    for (i = 0; i < n; i++) ans[i] = 0;
    while ((!step) || (convergence(ans, matrix, f, n) > eps)) {
        step++;
        for (i = 0; i < n; i++) {
            pre_ans[i] = ans[i];
        }
        for (i = 0; i < n; i++) {
            sum = 0.;
            for (j = 0; j < i; j ++){
                sum += matrix[i][j] * ans[j];
            }
            for (j = i; j < n; j++) {
                sum += matrix[i][j] * pre_ans[j];
            }
            ans[i] = pre_ans[i] + (f[i] - sum) * (omega / matrix[i][i]);
        }
    }
    return step;
}

double **matrix_transpose(double **matrix, int n) {
    int i, j;
    double **res;
    res = calloc(n, sizeof(*res));
    for (i = 0; i < n; i++) {
        res[i] = calloc (n, sizeof(**res));
    }
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            res[i][j] = matrix[j][i];
        }
    }
    return res;
}


double **matrix_multiplication(double **matrix_1, double **matrix_2, int n) {
    int i, j, k;
    double **res, sum;
    res = calloc(n, sizeof(*res));
    for (i = 0; i < n; i++) {
        res[i] = calloc (n, sizeof(**res));
    }
    for (i = 0; i < n; i++) {
        for (k = 0; k < n; k++) {
            sum = 0.;
            for(j = 0; j < n; j++) {
                sum += matrix_1[i][j] * matrix_2[j][k];
            }
            res[i][k] = sum;
        }
    }
    return res;
}

double *matr_to_vec_mult(double **matr, double *vector, int n) {
    double *res, sum;
    int i, j;
    res = calloc(n, sizeof(*res));
    for (i = 0; i < n; i++) {
        sum = 0.;
        for (j = 0; j < n; j++) {
            sum += matr[i][j] * vector[j];
        }
        res[i] = sum;
    }
    return res;
}

void free_all(double **m, double *v, int n);

int main(int argc, char **argv) {
    double tmp_num = 0.1, w, eps = 10e-6;
    printf("Введите способ ввода матриц\n");
    printf("0 - по формуле, или 1 или 2 или 3 - номер примера\n");
    int n = 4, flag;
    scanf("%d", &flag);
    if (flag == 0) n = 20;

    double **matrix = calloc(n, sizeof(*matrix));
    for (int i = 0; i < n; i++) matrix[i] = calloc(n, sizeof(**matrix));
    double *f_vector = calloc(n, sizeof(*f_vector));
    ans = calloc(n, sizeof(*ans));
    if (flag == 0) {
        gen_matrix(n, &matrix);
        find_f_vector(matrix, &f_vector, n);
        printf("\nСгенерированная система:\n");
        printf("Сгенерированный вектор x всегда единичный вектор длины n\n");
        print_matrix(matrix, n, f_vector);
        
    } else {
        FILE *fd;
        if (flag == 1) {
            fd = fopen("/home/uliana/Programm/CHMI/1.txt", "r");
        } else if (flag == 2) {
            fd = fopen("/home/uliana/Programm/CHMI/2.txt", "r");
        } else {
            fd = fopen("/home/uliana/Programm/CHMI/3.txt", "r");
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                fscanf(fd, "%lf", &matrix[i][j]);
            }
            fscanf(fd, "%lf", &f_vector[i]);
        }
        fclose(fd);
    }
    
    
    double **matrix_1 = copy_matrix(matrix, n);
    double *vector_f1 = copy_vector(f_vector, n);

    printf("Приведём матрицу и вектор правой части к симметричному виду:\n");
    matrix_1 = matrix_transpose(matrix_1, n);
    matrix = matrix_multiplication(matrix_1, matrix, n);
    vector_f1 = matr_to_vec_mult(matrix_1, vector_f1, n);
    print_matrix(matrix, n, vector_f1);
    printf ("Заданная точность: %lf\n", eps);
    
    for (w = 0.1; w < 2; w += 0.1) {
        int it = over_relaxation_method(matrix,vector_f1, n, w, eps);
        printf ("w = %.2lf количество итераций - %d\nОтвет:", w,it);
        print_vector(ans, n);
    }

    free_all(matrix_1, vector_f1, n);
    free_all(matrix, f_vector, n);

    return 0;
}


\end{lstlisting}


\section{Тестирование программы 2}
Проверка корректности программы проведена с помощью тестов из моего варианта и онлайн программ, позволяющих вычислить определитель матрицы,обратную матрицу или решить систему.

\subsection{Приложение 1. Вариант 9.}
\subsubsection{Первая система}

\begin{equation*}
 \begin{cases}
   2x_1 - 5x_2 + 3x_3 + x_4 = 5, 
   \\
   3x_1 - 7x_2 + 3x_3 - x_4 = -1,
   \\
   5x_1 - 9x_2 + 6x_3 + 2x_4 = 7,
   \\
   4x_1 - 6x_2 + 3x_3 + x_4 = 8,
 \end{cases}
\end{equation*}

Вывод моей программы:

\begin{verbatim}
Введите способ ввода матриц
0 - по формуле, или 1 или 2 или 3 - номер примера
1
Приведём матрицу и вектор правой части к симметричному виду:
|  54.00000 -100.00000   57.00000   13.00000  |  *  |x|  =  |  74.00000 |
|-100.00000  191.00000 -108.00000  -22.00000  |  *  |x|  =  |-129.00000 |
|  57.00000 -108.00000   63.00000   15.00000  |  *  |x|  =  |  78.00000 |
|  13.00000  -22.00000   15.00000    7.00000  |  *  |x|  =  |  28.00000 |

Заданная точность: 0.000010
w = 0.10 количество итераций - 58058
Ответ:   0.00002   -2.99998   -5.33330    5.99998 
w = 0.20 количество итераций - 27543
Ответ:   0.00002   -2.99998   -5.33330    5.99998 
w = 0.30 количество итераций - 17368
Ответ:   0.00002   -2.99998   -5.33330    5.99998 
w = 0.40 количество итераций - 12278
Ответ:   0.00002   -2.99998   -5.33330    5.99998 
w = 0.50 количество итераций - 9221
Ответ:   0.00002   -2.99998   -5.33330    5.99998 
w = 0.60 количество итераций - 7181
Ответ:   0.00002   -2.99998   -5.33330    5.99998 
w = 0.70 количество итераций - 5721
Ответ:   0.00002   -2.99998   -5.33330    5.99998 
w = 0.80 количество итераций - 4623
Ответ:   0.00002   -2.99998   -5.33331    5.99998 
w = 0.90 количество итераций - 3765
Ответ:   0.00002   -2.99998   -5.33331    5.99998 
w = 1.00 количество итераций - 3074
Ответ:   0.00002   -2.99998   -5.33331    5.99998 
w = 1.10 количество итераций - 2503
Ответ:   0.00002   -2.99998   -5.33331    5.99998 
w = 1.20 количество итераций - 2018
Ответ:   0.00002   -2.99998   -5.33331    5.99998 
w = 1.30 количество итераций - 1596
Ответ:   0.00001   -2.99998   -5.33331    5.99998 
w = 1.40 количество итераций - 1213
Ответ:   0.00001   -2.99998   -5.33332    5.99999 
w = 1.50 количество итераций - 820
Ответ:   0.00001   -2.99999   -5.33332    5.99999 
w = 1.60 количество итераций - 679
Ответ:   0.00001   -3.00000   -5.33333    6.00000 
w = 1.70 количество итераций - 864
Ответ:  -0.00001   -3.00001   -5.33334    6.00001 
w = 1.80 количество итераций - 1269
Ответ:  -0.00001   -3.00001   -5.33334    6.00000 
w = 1.90 количество итераций - 2522
Ответ:   0.00000   -3.00000   -5.33334    6.00000 

\end{verbatim}

Решение системы были найдены с помощью сайта
https://ru.onlinemschool.com/math/assistance/equation/matr/

(Относится ко всем трем системам Приложения 1)

Вывод программы совпал с ответами на сайтах, значит, программа работает верно.
Лучшая сходимость при омега = 1.9
К симметрическому виду матрица действительно была приведена.
\subsubsection{Вторая система}

\begin{equation*}
 \begin{cases}
   4x_1 + 3x_2 - 9x_3 + x_4 = 9
   \\
   2x_1 + 5x_2 - 8x_3 - x_4 = 8
   \\
   2x_1 + 16x_2 - 14x_3 + 2x_4 = 24
   \\
   2x_1 + 3x_2 - 5x_3  - 11x_4 = 7
 \end{cases}
\end{equation*}


Вывод моей программы:

\begin{verbatim}
Введите способ ввода матриц
0 - по формуле, или 1 или 2 или 3 - номер примера
2
Приведём матрицу и вектор правой части к симметричному виду:
|  28.00000   60.00000  -90.00000  -16.00000  |  *  |x|  =  | 114.00000 |
|  60.00000  299.00000 -306.00000   -3.00000  |  *  |x|  =  | 472.00000 |
| -90.00000 -306.00000  366.00000   26.00000  |  *  |x|  =  |-516.00000 |
| -16.00000   -3.00000   26.00000  127.00000  |  *  |x|  =  | -28.00000 |

Заданная точность: 0.000010
w = 0.10 количество итераций - 47312
Ответ:   2.99998    1.99999    0.99999   -0.00000 
w = 0.20 количество итераций - 22316
Ответ:   2.99998    1.99999    0.99999   -0.00000 
w = 0.30 количество итераций - 13990
Ответ:   2.99998    1.99999    0.99999   -0.00000 
w = 0.40 количество итераций - 9832
Ответ:   2.99998    1.99999    0.99999   -0.00000 
w = 0.50 количество итераций - 7341
Ответ:   2.99998    1.99999    0.99999   -0.00000 
w = 0.60 количество итераций - 5684
Ответ:   2.99998    1.99999    0.99999   -0.00000 
w = 0.70 количество итераций - 4501
Ответ:   2.99998    1.99999    0.99999   -0.00000 
w = 0.80 количество итераций - 3612
Ответ:   2.99998    1.99999    0.99999   -0.00000 
w = 0.90 количество итераций - 2914
Ответ:   2.99999    1.99999    0.99999   -0.00000 
w = 1.00 количество итераций - 2339
Ответ:   2.99999    2.00000    0.99999   -0.00000 
w = 1.10 количество итераций - 1826
Ответ:   2.99999    2.00000    0.99999   -0.00000 
w = 1.20 количество итераций - 1251
Ответ:   3.00001    2.00000    1.00000    0.00000 
w = 1.30 количество итераций - 1293
Ответ:   3.00001    2.00000    1.00000    0.00000 
w = 1.40 количество итераций - 1114
Ответ:   3.00001    2.00000    1.00000    0.00000 
w = 1.50 количество итераций - 916
Ответ:   3.00000    2.00000    1.00000    0.00000 
w = 1.60 количество итераций - 716
Ответ:   3.00000    2.00000    1.00000    0.00000 
w = 1.70 количество итераций - 514
Ответ:   3.00000    2.00000    1.00000    0.00000 
w = 1.80 количество итераций - 279
Ответ:   3.00000    2.00000    1.00000    0.00000 
w = 1.90 количество итераций - 329
Ответ:   3.00001    2.00000    1.00000    0.00000 

\end{verbatim}


Вывод программы совпал с ответами на сайтах, значит, программа работает верно.
Лучшая сходимость при омега = 1.5 и до омега = 1.9
К симметрическому виду матрица действительно была приведена.

\subsubsection{Третья система}

\begin{equation*}
 \begin{cases}
   12x_1 + 14x_2 - 15x_3 + 24x_4 = 5 
   \\
   16x_1 + 18x_2 - 22x_3 + 24x_4 = 8
   \\
   18x_1 + 20x_2 - 21x_3 + 32x_4 = 9
   \\
   10x_1 + 12x_2 - 16x_3 + 20x_4 = 4
 \end{cases}
\end{equation*}


Вывод моей программы:

\begin{verbatim}
Введите способ ввода матриц
0 - по формуле, или 1 или 2 или 3 - номер примера
3
Приведём матрицу и вектор правой части к симметричному виду:
| 824.00000  936.00000 -1070.00000 1528.00000  |  *  |x|  =  | 390.00000 |
| 936.00000 1064.00000 -1218.00000 1738.00000  |  *  |x|  =  | 442.00000 |
|-1070.00000 -1218.00000 1406.00000 -1990.00000  |  *  |x|  =  |-504.00000 |
|1528.00000 1738.00000 -1990.00000 2841.00000  |  *  |x|  =  | 720.00000 |

Заданная точность: 0.000010
w = 0.10 количество итераций - 6658245
Ответ:   2.22185   -1.66602   -0.11107   -0.00017 
w = 0.20 количество итераций - 3142846
Ответ:   2.22185   -1.66601   -0.11107   -0.00017 
w = 0.30 количество итераций - 1971984
Ответ:   2.22184   -1.66601   -0.11107   -0.00017 
w = 0.40 количество итераций - 1387409
Ответ:   2.22184   -1.66601   -0.11107   -0.00017 
w = 0.50 количество итераций - 1037476
Ответ:   2.22185   -1.66602   -0.11107   -0.00017 
w = 0.60 количество итераций - 804955
Ответ:   2.22185   -1.66603   -0.11107   -0.00016 
w = 0.70 количество итераций - 639569
Ответ:   2.22186   -1.66605   -0.11107   -0.00016 
w = 0.80 количество итераций - 516109
Ответ:   2.22188   -1.66607   -0.11107   -0.00015 
w = 0.90 количество итераций - 420476
Ответ:   2.22190   -1.66611   -0.11108   -0.00014 
w = 1.00 количество итераций - 344086
Ответ:   2.22193   -1.66616   -0.11108   -0.00013 
w = 1.10 количество итераций - 281334
Ответ:   2.22196   -1.66622   -0.11108   -0.00011 
w = 1.20 количество итераций - 228291
Ответ:   2.22200   -1.66628   -0.11109   -0.00010 
w = 1.30 количество итераций - 181859
Ответ:   2.22203   -1.66634   -0.11109   -0.00008 
w = 1.40 количество итераций - 138484
Ответ:   2.22207   -1.66640   -0.11109   -0.00007 
w = 1.50 количество итераций - 71768
Ответ:   2.22210   -1.66646   -0.11110   -0.00005 
w = 1.60 количество итераций - 87754
Ответ:   2.22232   -1.66682   -0.11112    0.00004 
w = 1.70 количество итераций - 69424
Ответ:   2.22229   -1.66677   -0.11112    0.00003 
w = 1.80 количество итераций - 40546
Ответ:   2.22225   -1.66672   -0.11111    0.00001 
w = 1.90 количество итераций - 52350
Ответ:   2.22226   -1.66674   -0.11112    0.00002

\end{verbatim}


Вывод программы совпал с ответами на сайтах, значит, программа работает верно.
Лучшая сходимость при омега = 1.8
К симметрическому виду матрица действительно была приведена.

\newpage

\subsection{Приложение 2. Вариант 2-2}

Формуру я придумала сама, в коде программы можно посмотреть ее реализацию.

Программа выводит в том числе и сгенерированную матрицу и вектор правой части.
Размер матрицы 20 на 20.


Вывод моей программы:

\begin{verbatim}
Введите способ ввода матриц
0 - по формуле, или 1 или 2 или 3 - номер примера
0

Сгенерированная система:
Сгенерированный вектор x всегда единичный вектор длины n
|   0.33333    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.36500 |
|   0.00167    0.83333    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.86500 |
|   0.00167    0.00167    0.16667    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.19833 |
|   0.00167    0.00167    0.00167    0.66667    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.69833 |
|   0.00167    0.00167    0.00167    0.00167    0.00000    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.03167 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.50000    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.53167 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    1.00000    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   1.03167 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.33333    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.36500 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.83333    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.86500 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.16667    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.19833 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.66667    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.69833 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00000    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.03167 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.50000    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.53167 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    1.00000    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   1.03167 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.33333    0.00167    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.36500 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.83333    0.00167    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.86500 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.16667    0.00167    0.00167    0.00167  |  *  |x|  =  |   0.19833 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.66667    0.00167    0.00167  |  *  |x|  =  |   0.69833 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00000    0.00167  |  *  |x|  =  |   0.03167 |
|   0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.00167    0.50000  |  *  |x|  =  |   0.53167 |

Приведём матрицу и вектор правой части к симметричному виду:
|   0.11116    0.00199    0.00088    0.00172    0.00061    0.00144    0.00227    0.00116    0.00199    0.00088    0.00172    0.00061    0.00144    0.00227    0.00116    0.00199    0.00088    0.00172    0.00061    0.00144  |  *  |x|  =  |   0.13795 |
|   0.00199    0.69450    0.00172    0.00255    0.00144    0.00227    0.00311    0.00199    0.00283    0.00172    0.00255    0.00144    0.00227    0.00311    0.00199    0.00283    0.00172    0.00255    0.00144    0.00227  |  *  |x|  =  |   0.73628 |
|   0.00088    0.00172    0.02783    0.00144    0.00033    0.00116    0.00199    0.00088    0.00172    0.00061    0.00144    0.00033    0.00116    0.00199    0.00088    0.00172    0.00061    0.00144    0.00033    0.00116  |  *  |x|  =  |   0.04961 |
|   0.00172    0.00255    0.00144    0.44450    0.00116    0.00199    0.00283    0.00172    0.00255    0.00144    0.00227    0.00116    0.00199    0.00283    0.00172    0.00255    0.00144    0.00227    0.00116    0.00199  |  *  |x|  =  |   0.48128 |
|   0.00061    0.00144    0.00033    0.00116    0.00005    0.00088    0.00172    0.00061    0.00144    0.00033    0.00116    0.00005    0.00088    0.00172    0.00061    0.00144    0.00033    0.00116    0.00005    0.00088  |  *  |x|  =  |   0.01684 |
|   0.00144    0.00227    0.00116    0.00199    0.00088    0.25005    0.00255    0.00144    0.00227    0.00116    0.00199    0.00088    0.00172    0.00255    0.00144    0.00227    0.00116    0.00199    0.00088    0.00172  |  *  |x|  =  |   0.28184 |
|   0.00227    0.00311    0.00199    0.00283    0.00172    0.00255    1.00005    0.00227    0.00311    0.00199    0.00283    0.00172    0.00255    0.00338    0.00227    0.00311    0.00199    0.00283    0.00172    0.00255  |  *  |x|  =  |   1.04684 |
|   0.00116    0.00199    0.00088    0.00172    0.00061    0.00144    0.00227    0.11116    0.00199    0.00088    0.00172    0.00061    0.00144    0.00227    0.00116    0.00199    0.00088    0.00172    0.00061    0.00144  |  *  |x|  =  |   0.13795 |
|   0.00199    0.00283    0.00172    0.00255    0.00144    0.00227    0.00311    0.00199    0.69450    0.00172    0.00255    0.00144    0.00227    0.00311    0.00199    0.00283    0.00172    0.00255    0.00144    0.00227  |  *  |x|  =  |   0.73628 |
|   0.00088    0.00172    0.00061    0.00144    0.00033    0.00116    0.00199    0.00088    0.00172    0.02783    0.00144    0.00033    0.00116    0.00199    0.00088    0.00172    0.00061    0.00144    0.00033    0.00116  |  *  |x|  =  |   0.04961 |
|   0.00172    0.00255    0.00144    0.00227    0.00116    0.00199    0.00283    0.00172    0.00255    0.00144    0.44450    0.00116    0.00199    0.00283    0.00172    0.00255    0.00144    0.00227    0.00116    0.00199  |  *  |x|  =  |   0.48128 |
|   0.00061    0.00144    0.00033    0.00116    0.00005    0.00088    0.00172    0.00061    0.00144    0.00033    0.00116    0.00005    0.00088    0.00172    0.00061    0.00144    0.00033    0.00116    0.00005    0.00088  |  *  |x|  =  |   0.01684 |
|   0.00144    0.00227    0.00116    0.00199    0.00088    0.00172    0.00255    0.00144    0.00227    0.00116    0.00199    0.00088    0.25005    0.00255    0.00144    0.00227    0.00116    0.00199    0.00088    0.00172  |  *  |x|  =  |   0.28184 |
|   0.00227    0.00311    0.00199    0.00283    0.00172    0.00255    0.00338    0.00227    0.00311    0.00199    0.00283    0.00172    0.00255    1.00005    0.00227    0.00311    0.00199    0.00283    0.00172    0.00255  |  *  |x|  =  |   1.04684 |
|   0.00116    0.00199    0.00088    0.00172    0.00061    0.00144    0.00227    0.00116    0.00199    0.00088    0.00172    0.00061    0.00144    0.00227    0.11116    0.00199    0.00088    0.00172    0.00061    0.00144  |  *  |x|  =  |   0.13795 |
|   0.00199    0.00283    0.00172    0.00255    0.00144    0.00227    0.00311    0.00199    0.00283    0.00172    0.00255    0.00144    0.00227    0.00311    0.00199    0.69450    0.00172    0.00255    0.00144    0.00227  |  *  |x|  =  |   0.73628 |
|   0.00088    0.00172    0.00061    0.00144    0.00033    0.00116    0.00199    0.00088    0.00172    0.00061    0.00144    0.00033    0.00116    0.00199    0.00088    0.00172    0.02783    0.00144    0.00033    0.00116  |  *  |x|  =  |   0.04961 |
|   0.00172    0.00255    0.00144    0.00227    0.00116    0.00199    0.00283    0.00172    0.00255    0.00144    0.00227    0.00116    0.00199    0.00283    0.00172    0.00255    0.00144    0.44450    0.00116    0.00199  |  *  |x|  =  |   0.48128 |
|   0.00061    0.00144    0.00033    0.00116    0.00005    0.00088    0.00172    0.00061    0.00144    0.00033    0.00116    0.00005    0.00088    0.00172    0.00061    0.00144    0.00033    0.00116    0.00005    0.00088  |  *  |x|  =  |   0.01684 |
|   0.00144    0.00227    0.00116    0.00199    0.00088    0.00172    0.00255    0.00144    0.00227    0.00116    0.00199    0.00088    0.00172    0.00255    0.00144    0.00227    0.00116    0.00199    0.00088    0.25005  |  *  |x|  =  |   0.28184 |

Заданная точность: 0.000010
w = 0.10 количество итераций - 1664
Ответ:   0.99976    0.99990    0.99952    0.99988    1.01770    0.99984    0.99992    0.99976    0.99990    0.99952    0.99988    1.01653    0.99984    0.99992    0.99976    0.99991    0.99952    0.99988    1.01423    0.99984 
w = 0.20 количество итераций - 787
Ответ:   0.99976    0.99990    0.99951    0.99988    1.01877    0.99984    0.99992    0.99976    0.99991    0.99952    0.99988    1.01781    0.99984    0.99992    0.99976    0.99991    0.99952    0.99988    1.01179    0.99984 
w = 0.30 количество итераций - 494
Ответ:   0.99976    0.99990    0.99951    0.99988    1.01908    0.99984    0.99992    0.99976    0.99990    0.99951    0.99988    1.02047    0.99984    0.99992    0.99976    0.99991    0.99952    0.99988    1.00909    0.99984 
w = 0.40 количество итераций - 348
Ответ:   0.99976    0.99990    0.99951    0.99988    1.01744    0.99984    0.99992    0.99976    0.99991    0.99952    0.99988    1.02439    0.99984    0.99992    0.99976    0.99991    0.99952    0.99988    1.00631    0.99984 
w = 0.50 количество итераций - 261
Ответ:   0.99977    0.99991    0.99953    0.99988    1.01256    0.99985    0.99992    0.99977    0.99991    0.99953    0.99989    1.02936    0.99985    0.99993    0.99977    0.99991    0.99954    0.99989    1.00446    0.99985 
w = 0.60 количество итераций - 203
Ответ:   0.99978    0.99991    0.99955    0.99989    1.00318    0.99985    0.99993    0.99978    0.99991    0.99955    0.99989    1.03528    0.99986    0.99993    0.99979    0.99992    0.99957    0.99989    1.00563    0.99986 
w = 0.70 количество итераций - 165
Ответ:   0.99983    0.99993    0.99965    0.99991    0.98867    0.99988    0.99994    0.99982    0.99993    0.99964    0.99991    1.03298    0.99989    0.99995    0.99983    0.99993    0.99966    0.99992    1.01271    0.99989 
w = 0.80 количество итераций - 140
Ответ:   0.99990    0.99996    0.99979    0.99995    0.97957    0.99993    0.99996    0.99989    0.99996    0.99977    0.99994    1.01593    0.99993    0.99997    0.99990    0.99996    0.99979    0.99995    1.02494    0.99994 
w = 0.90 количество итераций - 123
Ответ:   0.99995    0.99998    0.99990    0.99998    0.98917    0.99996    0.99998    0.99994    0.99998    0.99988    0.99997    0.98922    0.99996    0.99998    0.99994    0.99998    0.99988    0.99997    1.03156    0.99997 
w = 1.00 количество итераций - 109
Ответ:   0.99997    0.99999    0.99994    0.99998    1.01755    0.99998    0.99999    0.99997    0.99999    0.99993    0.99998    0.96613    0.99997    0.99998    0.99995    0.99998    0.99990    0.99998    1.02272    0.99998 
w = 1.10 количество итераций - 103
Ответ:   0.99998    0.99999    0.99996    0.99999    1.03794    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    0.98897    0.99999    0.99999    0.99998    0.99999    0.99996    0.99999    0.97675    0.99999 
w = 1.20 количество итераций - 105
Ответ:   1.00001    1.00000    1.00001    1.00000    0.98296    1.00001    1.00000    1.00001    1.00000    1.00002    1.00000    1.02612    1.00002    1.00001    1.00002    1.00001    1.00005    1.00001    0.98948    1.00000 
w = 1.30 количество итераций - 112
Ответ:   1.00000    1.00000    1.00000    1.00000    1.00405    0.99999    1.00000    0.99999    1.00000    0.99998    0.99999    0.98049    0.99999    0.99999    0.99998    0.99999    0.99997    0.99999    1.01571    1.00000 
w = 1.40 количество итераций - 124
Ответ:   1.00000    1.00000    1.00000    1.00000    0.99060    1.00001    1.00000    1.00001    1.00000    1.00002    1.00000    1.01938    1.00001    1.00001    1.00002    1.00001    1.00004    1.00001    0.98962    1.00000 
w = 1.50 количество итераций - 140
Ответ:   0.99999    1.00000    0.99999    1.00000    1.02848    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    0.98254    0.99999    0.99999    0.99998    0.99999    0.99995    0.99999    0.99023    1.00000 
w = 1.60 количество итераций - 173
Ответ:   1.00000    1.00000    0.99999    1.00000    1.03185    1.00000    1.00000    1.00001    1.00000    1.00001    1.00000    0.98767    0.99999    0.99999    0.99998    0.99999    0.99996    0.99999    0.98162    1.00000 
w = 1.70 количество итераций - 241
Ответ:   1.00000    1.00000    1.00000    1.00000    1.02363    1.00000    1.00000    1.00000    1.00000    1.00000    1.00000    0.98337    0.99999    0.99999    0.99998    0.99999    0.99996    0.99999    0.99347    1.00000 
w = 1.80 количество итераций - 369
Ответ:   1.00000    1.00000    1.00000    1.00000    0.97270    1.00000    1.00000    1.00000    1.00000    0.99999    1.00000    1.01312    1.00001    1.00001    1.00002    1.00001    1.00004    1.00001    1.01381    1.00000 
w = 1.90 количество итераций - 760
Ответ:   1.00000    1.00000    1.00000    1.00000    1.02895    1.00001    1.00000    1.00001    1.00000    1.00002    1.00000    0.99453    0.99999    0.99999    0.99998    0.99999    0.99996    0.99999    0.97674    1.00000
\end{verbatim}

Лучшая сходимость при омега = 1.2 (значем, что ответ - единичный вектор)
К симметрическому виду матрица действительно была приведена.

\newpage

\section{Выводы}
В ходе работы изучен и реализован классический метод Гаусса и модифицированный метод Гаусса - с выбором главного элемента. Также реализованы алгоритмы нахождения определителя матрицы, обратной матрицы. Корректность решений проверена системой тестов при помощи онлайн программ в интернете.
Аналогично реализован метод верхней релаксации, проверен на тех же системах с помощью тех же сайтов. Для корректной работы данного метода следует проверить сходимость. Поэтому не во всех системах получено верное решение
\end{document}